좋습니다. GovChat 프로젝트에 대해 다음 환경을 세팅하는 작업을 진행하겠습니다:

* 실명인증을 포함한 최소 사용자 정보 저장 구조 설계
* 홈/소개 화면 외 나머지는 로그인 필요하도록 설정
* 테스트 관리자 계정([arcth723@gmail.com](mailto:arcth723@gmail.com)) 생성 및 DB 저장
* 정부 및 공공기관 사업 정보 API 연동 환경 구상

완료되면 바로 알려드릴게요.


# GovChat 사용자 인증 및 API 기반 데이터 입력 환경 설계

## 개요

GovChat 프로젝트를 위한 **사용자 인증 체계**와 **공공 API 기반 데이터 입력 환경**에 대한 설계 내용을 제시합니다. 설계에서는 최소한의 개인정보만을 수집하고 외부 본인인증 API를 활용한 실명 인증, 로그인/세션 관리, 관리자 및 일반 사용자 권한 분리를 통한 보안 강화, 그리고 정부 지원사업 데이터를 외부 공공데이터 API로부터 수집/저장/관리하는 구조를 포함합니다. 아래에서는 데이터베이스 모델링, 인증 및 회원가입 플로우, 접근 권한 설계, 외부 API 연동과 사업정보 처리 방식 등에 대해 상세히 설명합니다.

## 데이터베이스 모델링

**데이터베이스**는 사용자 정보와 정부 지원사업 정보를 저장합니다. 최소한의 정규화된 스키마로 보안을 강화하고 데이터 중복을 피합니다.

* **사용자 테이블 (Users)**: 사용자 계정 정보를 저장합니다. 필수 컬럼은 **이메일(email)**, **비밀번호 해시(password\_hash)**, \*\*이름(name)\*\*이며 이외에 실명 인증 상태를 표시하는 **인증여부(verified)** 플래그, **역할(role)** 등이 있습니다. 이메일은 고유 키(unique)로 설정하여 중복 가입을 방지합니다. 비밀번호는 평문을 저장하지 않고 **bcrypt와 같은 해시 알고리즘으로 암호화**하여 저장합니다. 이름은 사용자의 실명을 저장하되, 추가 민감정보(예: 주민번호, 전화번호 등)는 저장하지 않습니다. 이는 **데이터 최소 수집 원칙**을 따른 것으로, 업무에 불필요한 개인정보는 수집/저장하지 않아 보안 위험을 줄입니다. 실명 인증과 관련된 정보도 **인증 완료 여부**만 표시하고 구체적인 개인식별정보는 DB에 저장하지 않습니다.
  *예:* Users(id PK, email, password\_hash, name, verified BOOL, role ENUM('user','admin',...), created\_at, etc.)

* **권한/역할 테이블 (Roles)** *(선택 사항)*: 사용자 권한이 복잡해질 경우를 대비하여 역할 정보를 별도 테이블로 관리할 수 있습니다. 단순히 관리자와 일반 사용자 정도로 구분하는 경우에는 Users 테이블의 role 필드(enum 또는 boolean)로 충분합니다. 향후 확장성을 위해 역할 테이블과 **사용자-역할 매핑 테이블**을 두면 다대다 관계의 역할 구성이 가능합니다 (예: ADMIN, DATA\_MANAGER, USER 등 다층 역할).

* **사업정보 테이블 (Projects 또는 Policies)**: 정부 및 지자체 등이 시행하는 **재정지원사업** 데이터를 저장합니다. 각 레코드는 하나의 지원사업을 나타내며, 주요 컬럼으로 **사업ID(project\_id)**, **사업명(title)**, **주관기관(agency)**, **지원내용(description)**, **대상(target\_audience)**, **신청기간(application\_period)**, **출처(source)** 등이 있습니다. `project_id`는 내부 고유 식별자이며, 외부 공공데이터에서 제공되는 식별자(예: 정책 ID `policyId`)가 있다면 별도 필드로 저장하여 외부 데이터와의 연계를 유지합니다. 또한 `source` 필드를 둬서 데이터 출처를 구분할 수 있습니다 (예: `external` 또는 `manual`). 이는 외부 API로 불러온 데이터인지 관리자 수동 입력 데이터인지 나타내어 **동기화 관리**에 활용합니다.
  *예:* Projects(project\_id PK, policy\_external\_id, title, agency, description, target, start\_date, end\_date, source, last\_updated, etc.)

* **기타 테이블**: 추가 기능에 따라 세션 관리 테이블이나 로그 테이블 등이 있을 수 있습니다. GovChat의 인증은 OAuth/OIDC 표준에 따라 **세션을 DB에 저장**할 수 있으며 (예: DynamoDB를 세션 저장소로 사용), 이는 NextAuth 등의 인증 프레임워크를 통해 구현됩니다. 다만 본 설계에서는 JWT 토큰을 활용한 세션 방식(후술)을 채택하여 별도 세션 테이블 없이 인증을 처리할 수도 있습니다.

## 인증 및 회원가입 플로우

사용자 가입과 로그인의 흐름은 **보안**과 **편의성**을 균형 있게 고려합니다. 최소 정보로 가입을 받되, **실명 인증 절차**를 통해 신뢰성을 확보합니다. 또한 비밀번호는 안전하게 관리하고, 세션은 적절히 유지/만료되도록 설계합니다.

### 1. 회원가입 절차 및 실명 인증

1. **회원가입 폼**: 사용자는 이메일, 비밀번호, 이름을 입력하여 가입을 신청합니다. 입력한 이름은 실제 본인 이름이어야 하며, 비밀번호는 일정 강도 요건(예: 8자 이상, 특수문자 포함 등)을 충족하도록 검증합니다.
2. **이메일 중복 확인**: 서버는 입력된 이메일이 기존 사용자와 중복되지 않는지 확인합니다. 중복일 경우 오류를 반환합니다.
3. **실명 인증 요청**: 가입 폼 제출 시, 입력된 이름에 대해 **실명 확인 절차**를 진행합니다. 민간 본인인증 서비스를 연동하여 사용자가 본인 명의의 휴대전화 등으로 인증하도록 유도합니다. 예를 들어, 통신사 기반 PASS 인증이나 KISA 연계 본인확인 API를 호출할 수 있습니다. 사용자가 휴대폰 번호 등 추가 정보를 입력하면, 백엔드에서 해당 **본인인증 API**에 정보를 전송하고 일회성 인증을 수행합니다. 성공 시 응답으로 사용자 본인 여부 확인 및 인증값을 받습니다. 이때 외부 인증을 활용함으로써 서비스는 사용자의 신원만 확인하고 **민감한 신원 정보는 저장하지 않습니다** (예: 인증 결과로 받은 주민번호 등은 저장하지 않고 폐기).

   * *임시 방안*: 만약 외부 본인인증 API를 사용하지 못하는 단계라면, 사용자 입력 기반으로 일단 가입을 허용하되 **verified** 상태를 `false`로 두고, 추후 인증을 요구할 수 있습니다. 하지만 해당 방법은 신뢰도가 낮으므로, 가급적 빠른 시점에 공식 본인인증 연계를 구현하는 것을 권장합니다.
4. **비밀번호 해시 및 저장**: 인증 성공 또는 임시로 진행된 경우, 사용자 레코드를 DB에 생성합니다. 이때 비밀번호는 평문이 아닌 **bcrypt 해시를 적용**하여 저장합니다. bcrypt 알고리즘은 솔트(salt)를 사용하여 같은 비밀번호도 매번 다른 해시로 저장되며, 해시 비용(cost)를 조정해 무차별 대입 공격을 어렵게 합니다. (예: `password_hash = bcrypt(plain_password)`로 저장). 또한 이메일은 소문자 변환 및 트림 등 정규화하여 일관되게 저장합니다.
5. **이메일 인증** *(선택사항)*: 보안을 강화하기 위해 가입한 이메일 주소에 확인 메일을 보내는 절차를 추가로 둘 수 있습니다. 사용자가 이메일의 인증 링크를 클릭해야 최종 활성화되는 방식입니다. 이 기능을 적용하면 **가짜 이메일 가입**을 걸러낼 수 있지만, 초기 간소화를 위해 필수 요구사항은 아닙니다.
6. **가입 완료 및 세션 처리**: 가입이 완료되면 사용자에게 환영 메세지를 표시하고 자동으로 로그인 처리할 수 있습니다. 이때 서버는 **세션 토큰**(예: JWT)을 발급하여 클라이언트에 전달합니다. JWT에는 사용자 식별자와 인증 정보(최소한의 claims만)를 포함하고 서명하여 위변조를 방지합니다. 클라이언트는 이 토큰을 **HTTP Only 쿠키**로 저장하거나 메모리에 저장한 후 이후 요청 시 인증 헤더로 제공하여 인증을 유지합니다. 토큰의 유효기간은 예를 들어 **30일** 등으로 설정하고, 장기간 미사용 시 만료되도록 합니다.

> **비밀번호 보안:** 사용자가 설정한 비밀번호는 해시화하여 저장하므로 관리자도 원문을 알 수 없습니다. 로그인 시 입력된 비밀번호를 같은 해시 알고리즘으로 변환하여 DB의 해시와 비교합니다. 이러한 설계로 비밀번호 유출 위험을 줄이고, 개발자나 DBA도 사용자 비밀번호 원문을 열람할 수 없게 합니다. 또한 향후 **다단계 인증(MFA)** 도입을 고려하여, 중요한 권한(admin 등) 계정에는 OTP를 통한 2차 인증을 추가할 수 있습니다.

### 2. 로그인 및 세션 관리

1. **로그인 폼**: 사용자는 가입 시 사용한 이메일과 비밀번호로 로그인합니다. (추가로 소셜 로그인이나 일회용 코드 로그인 등은 추후 도입 가능).
2. **자격 증명 확인**: 서버는 입력받은 이메일로 사용자 레코드를 조회합니다. 해당 이메일이 없으면 곧바로 인증 실패를 반환합니다. 이메일이 존재하면 저장된 비밀번호 해시와, 입력된 비밀번호의 해시를 **bcrypt 검증**으로 비교합니다. 일치하면 인증 성공입니다. 비밀번호 불일치 등의 경우, 일정 횟수 이상 실패 시 계정을 일시 잠그거나 캡차를 요구하는 등 **브루트포스 보호** 기능을 적용합니다 (예: 5회 이상 연속 실패 시 5분간 로그인 불가 등의 정책).
3. **실명 인증 확인**: 해당 사용자가 **verified=false**(실명 미인증) 상태라면, 로그인 성공이더라도 민감 기능 접근을 제한하거나 추가 인증을 요구할 수 있습니다. 예를 들어, 로그인 후 실명 인증을 다시 시도하게 하거나, 읽기 전용 권한만 주는 식입니다. (만약 가입 시 실명 인증을 완료했다면 verified=true일 것이므로 추가 조치 불필요).
4. **세션 생성**: 인증에 성공하면 서버는 새로운 세션이나 JWT를 발급합니다. 본 시스템은 무상태(stateless) JWT 기반 인증을 사용하므로, 서버가 별도 세션 저장을 하지 않고 JWT 자체로 인증을 유지합니다. JWT에는 사용자 ID, 역할, 토큰 만료시각 등이 들어 있으며, 서버 비밀키로 서명되어 클라이언트와 서버 간 신뢰를 확보합니다. 서버는 JWT의 유효성을 검사함으로써 매 요청마다 사용자 인증/권한을 확인합니다. (Next.js 기반 구현의 경우 NextAuth를 사용하여 JWT 세션 전략을 적용하며, React 서버 컴포넌트에서도 세션 정보를 손쉽게 활용하도록 합니다.)
5. **로그인 유지 및 로그아웃**: 클라이언트는 받은 JWT를 안전하게 저장(HTTP-Only 쿠키 권장)하여 이후 API 호출 시 포함시킵니다. JWT의 만료시간이 지나면 자동으로 인증이 만료되며, 갱신하려면 재로그인이 필요합니다. 사용자가 명시적으로 로그아웃하면 클라이언트측 쿠키/토큰을 삭제하고 서버측에서는 (상태ful 세션이라면 세션 만료 처리, JWT라면 특별한 서버 조치 없이) 클라이언트 토큰 폐기만으로 완료됩니다. 필요 시 서버는 JWT 블랙리스트나 Rolling JWT 기법으로 강제 만료시킬 수 있습니다.

> **소셜 로그인 지원:** GovChat은 OAuth2/OIDC 기반의 소셜 로그인을 지원하도록 설계될 수 있습니다. ADR에 따르면 Google, Kakao, Naver 등의 **복수 제공자 인증**을 NextAuth.js로 구현하기로 결정되었습니다. 따라서 사용자는 이메일/비밀번호 방식 외에도 소셜 계정으로 손쉽게 로그인 가능하며, OAuth를 통해 받은 프로필 정보로 사용자 DB를 업데이트합니다. 소셜 로그인 시에도 최초 연동 시 이메일, 이름 등을 가져와 DB에 저장하지만, 추가로 우리 서비스에서 요구하는 실명 인증은 별도로 진행해야 할 수 있습니다 (소셜 프로필의 이름이 실명이 아닐 수 있고, 각 소셜이 자체 본인확인을 거친 경우에 한해 신뢰할지를 정책으로 결정). 기본 회원가입/로그인 흐름은 위와 동일하며, 소셜 로그인 성공 시 해당 OAuth provider로부터 받은 토큰을 NextAuth가 검증 후 내부 JWT 세션으로 교체하여 처리합니다.

## 접근 권한 및 화면 구성

시스템은 **로그인 필요 여부**와 **관리자/일반 사용자 권한**에 따라 접근을 제어합니다. 원칙적으로 **홈, 소개 페이지 등 일반 공개 정보는 로그인 없이 접근 허용**하고, 사용자 개인정보가 노출되거나 데이터 입력·수정 기능 등은 로그인 후에만 가능하게 합니다. 또한 **관리자 전용 기능은 관리자 권한이 있는 계정만** 사용할 수 있습니다.

* **공개 페이지 (비인증 접근)**: GovChat의 홈 화면과 서비스 소개 페이지는 누구나 볼 수 있습니다. 이들 페이지에서는 서비스 개요, 사용 방법, 공지사항 등을 담을 수 있고, 사용자가 로그인하지 않은 상태에서도 접근이 허용됩니다. 이러한 페이지에서는 로그인 여부와 무관하게 조회만 가능하며, 별도의 민감한 데이터 노출이 없습니다. (예: 메인 홈페이지, "서비스 소개" 정적 컨텐츠 등은 Public URL로 제공).

* **일반 사용자 기능 (인증 필요)**: 사용자가 **로그인한 후**에야 이용할 수 있는 기능들입니다. 예를 들어, GovChat의 핵심 기능인 지원사업 검색 또는 Q\&A 챗봇 기능, 개인 대시보드 등이 이에 해당합니다. 로그인한 사용자만 지원사업 목록을 조회하거나 상세 정보를 열람할 수 있으며, 본인 프로필(이름, 가입일 등 최소 정보)도 확인 가능합니다. 이러한 페이지를 클라이언트 측에서는 보호하여, 인증이 없는 상태로 접근 시 로그인 페이지로 리디렉션시킵니다. 서버 측 API도 토큰 검증을 통해 **인증 헤더가 없는 요청은 401 Unauthorized**를 반환하게 됩니다.

* **관리자 전용 기능 (관리자 권한 필요)**: 관리자에게만 허용된 기능들과 화면이 존재합니다. 대표적으로 **지원사업 데이터 추가/수정/삭제** 화면, 사용자 관리 화면, 시스템 설정 화면 등이 있을 수 있습니다. 관리자용 페이지에 접근할 때는 **일반 사용자 권한인지 확인**하여, 관리자가 아니라면 접근 불가(예: 403 Forbidden 처리)하도록 합니다. 프론트엔드 라우팅 단계에서도 일반 사용자가 관리자 UI 메뉴를 볼 수 없게 숨기고, 혹여 직접 URL을 알아내 접속하더라도 서버에서 차단합니다.

  * *테스트 관리자 계정*: 사전에 데이터베이스에 **관리자 계정**을 생성해 두어야 합니다. 요구사항에서 지정한 테스트 관리자 계정은 이메일 `archt723@gmail.com`이며 초기 비밀번호는 `1q2w3e2w1q!`입니다. 이 계정은 role 필드가 'admin'으로 설정되어 있으며, 일반 사용자와 달리 관리자 전용 API 엔드포인트에 접근할 수 있습니다. 초기 비밀번호는 애플리케이션 배포 시 **bcrypt로 해시 처리**하여 저장해 둡니다 (예: `"$2b$12$..."` 형태로 DB에 저장). 관리자는 로그인 후 곧바로 이 비밀번호를 변경하도록 요구하거나, 해당 계정에만 MFA를 적용하는 등 추가 보안을 고려합니다.

* **개인정보 접근 제한**: 관리자라 하더라도 **일반 사용자의 민감한 개인정보를 임의로 열람할 수 없도록 설계**합니다. 원칙적으로 서비스에서는 비밀번호 해시 등 **민감 데이터는 저장하지도 않을뿐더러** UI에 노출하지 않습니다. 관리자 화면에서 사용자 목록을 보더라도, 각 사용자별로 **이메일, 이름, 가입일, 인증 여부** 정도의 최소 정보만 표시하고, 사용자의 비밀번호나 본인인증에 사용된 상세 정보(예: 휴대전화 번호, 인증 로그 등)는 조회할 수 없습니다. 이러한 접근 제한은 **직원 역할에 따른 데이터 접근 최소화 원칙**에 부합합니다. 필요 시 중요 개인정보는 별도 암호화 저장하여 DB 관리자도 열람이 불가능하게 하고, 해당 정보를 조회/복호화하는 별도 권한 절차를 마련합니다. 예를 들어, 만약 주민등록번호 등의 정보를 받아야 하는 경우 법적 요건상 관리자도 내용은 마스킹된 형태로만 보거나 아예 DB에 저장하지 않고 제3의 인증기관에서 보관하도록 합니다.

요약하면, **일반 사용자는 본인의 정보와 공개 데이터만 접근**하고 **관리자는 서비스 운영에 필요한 범위 내에서 데이터 수정 권한**을 가지며, **그 외 민감정보는 누구도 볼 수 없게** 함으로써 권한을 계층화합니다. 이러한 RBAC(Role-Based Access Control) 설계에 따라 사용자 역할별로 필요한 데이터에만 접근을 허용하고 그 외는 제한함으로써 보안을 강화합니다.

## 외부 API 연동 및 사업정보 관리

GovChat의 핵심 데이터 중 하나는 **정부 재정지원사업 정보**입니다. 이는 중앙정부, 지방자치단체 또는 산하기관 등이 국민이나 기업을 대상으로 제공하는 각종 **재정 지원 정책/사업**을 말합니다. 예를 들어 청년 창업지원금, 소상공인 지원대출, 농어민 보조금 등의 정보가 해당됩니다. 이 정보는 각 기관별로 흩어져 있을 수 있지만, **공공데이터 포털(data.go.kr)** 등의 **외부 공개 API**를 통해 통합 조회 및 제공받을 수 있습니다.

### 1. 외부 공공데이터 API 연동 설계

* **공공데이터 API 선택**: 정부는 공공데이터 포털을 통해 다양한 정책사업 정보를 제공하고 있습니다. 예시로, 중소기업청년정책통합 APIs, 지방보조금 사업 API 등이 존재합니다. 본 프로젝트에서는 이러한 API 중 **재정지원사업 통합 정보 API**를 활용합니다. (요구사항에 명시된 것은 아니지만, `data.go.kr`의 특정 API 키를 통해 다수 기관의 지원사업 정보를 검색/조회할 수 있는 엔드포인트가 있다고 가정합니다).

* **API 키 관리**: 공공데이터 API 호출에는 보통 인증키(API Key)가 필요합니다. 이 키는 외부에 노출되면 안 되므로, **서버 측 환경 변수나 시크릿 스토어**에 안전하게 보관합니다. (예: AWS Secrets Manager에 키를 저장하고 애플리케이션 실행 시 불러오기). 코드 상에 하드코딩하지 않고, 권한 있는 환경에서만 키를 읽어오도록 합니다.

* **데이터 수집 방식**:

  * *검색 및 상세조회*: 외부 API가 제공하는 기능에 따라, **키워드로 사업 검색** (예: "청년", "창업" 등의 키워드) 요청과 **상세 정보 조회** 요청으로 나눌 수 있습니다. 검색 API를 통해 관련 사업 리스트(요약 정보)를 받고, 각 항목의 ID로 상세 API를 호출하여 상세 정보를 얻는 구조입니다.
  * *정기 일괄 수집*: 주요 사업 정보를 일괄로 수집하기 위해, 초기에는 광범위한 키워드나 분류 코드를 사용하여 **모든 사업을 크롤링/동기화**합니다. 예를 들어, 페이지를 순회하며 (`page=1,2,...`) 모든 데이터를 가져와 DB에 저장합니다. 이후에는 정기적으로(예: 하루 혹은 주 단위) API를 호출하여 **신규/변경된 사업만 업데이트**합니다. 변경 여부는 외부 데이터의 수정일자나 버전 정보를 활용하거나, 우리 DB에 없는 `policy_external_id`가 나오면 신규로 간주하여 insert하고, 이미 있는 경우 내용이 바뀌었을 때 update하는 로직을 구현합니다.
  * *실시간 조회*: 추가로, 사용자가 특정 키워드로 검색할 때마다 실시간으로 외부 API를 조회하는 기능도 고려할 수 있습니다. 그러나 외부 API는 호출 제한과 응답 지연이 있을 수 있으므로, **기본적으로는 내부 DB에 동기화된 데이터를 우선 검색**하고, 없는 경우에만 외부 API를 조회하거나 관리자 기능으로만 외부 검색을 사용하도록 설계합니다. 이렇게 하면 일반 사용자의 조회는 빠르고 안정적으로 이루어지고, 외부 API 부하를 줄일 수 있습니다.

* **데이터 파싱 및 저장**: 외부 API로부터 JSON 혹은 XML 형태로 받은 응답을 파싱하여 우리 **Projects 테이블**에 저장합니다. 앞서 정의한 프로젝트 데이터 스키마에 맞게 필드를 매핑합니다. 예를 들어, 응답의 `policyId` -> `policy_external_id`, `policyName` -> `title`, `description` -> `description`, `organName` -> `agency`, `target` -> `target_audience`, `applyPeriod` -> `application_period` 등의 식으로 매핑합니다. 추가로 API가 제공하지 않는 부가 정보(예: 우리 서비스에서 분류한 카테고리 등)가 있다면, 기본값을 넣거나 관리자 입력을 통해 보완합니다. 저장 시 **트랜잭션**을 활용하여 일부만 저장되다 실패하는 경우를 방지하고, 저장 직후 캐시나 검색 인덱스를 갱신합니다.

  * *중복 처리*: 동일한 `policy_external_id`를 가진 데이터가 이미 존재하면 **UPDATE**를 수행하고, 없으면 **INSERT**를 합니다. 업데이트 시에는 기존에 관리자에 의해 수정된 필드가 있을 경우 **덮어쓰지 않도록** 유의해야 합니다. 이를 위해 `source`가 `manual`인 필드는 외부 동기화 시 건드리지 않는다거나, 또는 변경 내역을 로그로 남겨 추적할 수 있습니다. 초기 구현에서는 단순 덮어쓰기로 시작하고, 차후 필요 시 충돌 해결 전략을 마련합니다.
  * *오류 처리*: 외부 API 호출 실패나 응답 지연 시 재시도 전략을 적용합니다. 일정 횟수 실패하면 관리자에게 알림을 보내거나 로그를 남겨 추후 수동 처리하게 합니다. 또한 외부 API 스키마 변경에 대비해, 데이터 파싱부를 모듈화하고 유연하게 대처할 수 있도록 합니다.

### 2. 사업 정보 입력 및 관리 기능

* **관리자에 의한 수동 입력**: 외부 데이터만으로는 부족하거나, 외부 API에 아직 등록되지 않은 신규 지원사업 정보를 **관리자가 직접 입력**할 수 있어야 합니다. 이를 위해 관리자용 **사업 추가 페이지**를 제공합니다. 관리자 UI에서 사업명, 주관기관, 지원내용 등 필드를 입력하여 새 사업을 등록하면, 내부 Projects 테이블에 레코드가 생성됩니다 (`source = 'manual'`). 수동 입력된 사업도 일반 사용자에게는 똑같이 노출되고 검색됩니다. 단, `policy_external_id`는 없는 상태이므로 추후 동일 사업이 공공데이터 API에도 등장하면 중복될 수 있습니다. 이런 경우를 식별하기 위해 관리자에게 알림을 주거나, 수동 입력 시 어느 기관의 어떤 사업인지 명확히 기입하도록 안내하여 중복 여부를 사람이 판단하도록 합니다.
* **사업 정보 수정**: 관리자 또는 권한을 부여받은 담당자는 기존에 저장된 사업 정보를 편집할 수 있습니다. 예를 들어 지원 요건이나 신청기간이 변경되었을 때 이를 수정할 수 있습니다. 수정 UI에서는 Projects 레코드의 각 필드를 편집 가능하며, 수정 저장 시 변경된 내용과 시간을 기록해 둡니다 (추적을 위해 `last_updated`와 업데이트한 관리자 ID 등을 저장). 외부 연동된 데이터의 경우, 수정하면 `source`를 자동으로 `manual`로 바꾸거나 별도 플래그(예: `overridden = true`)를 두어 향후 동기화에서 제외시킵니다.
* **조회 및 검색**: 일반 사용자는 다양한 조건으로 지원사업을 **검색**하고 조회할 수 있습니다. 이를 위해 **키워드 검색**, 조건 필터(기관별, 대상별 등)를 지원합니다. 구현상으로는 DB에 적절한 **인덱스**를 설정하고, 필요하다면 \*\*전문 검색엔진(OpenSearch 등)\*\*을 도입하여 description 같이 긴 텍스트 필드에서의 키워드 검색 성능을 높입니다. 예컨대 Elasticsearch/OpenSearch에 사업명, 내용 등을 색인해 두고 사용자 검색 시 해당 엔진을 질의하여 결과를 가져오면 더욱 빠르게 정확한 검색이 가능합니다 (현재 프로젝트 종속성에 OpenSearch Python 클라이언트가 포함되어 있어 이를 활용할 수 있습니다). 다만 초기 단계에서는 데이터 건수가 많지 않다면 데이터베이스 풀텍스트 인덱스나 LIKE 검색으로도 처리 가능하므로, 구현 난이도에 따라 단계적으로 도입합니다.
* **API 제공 여부**: GovChat 서비스 자체가 수집한 지원사업 데이터를 외부에 제공할 필요가 있다면, **공개 REST API** 엔드포인트를 마련할 수 있습니다. 예를 들어 `/api/projects?keyword=...` 형태로 요청하면 인증된 사용자에게 JSON 목록을 주는 식입니다. 현재 요구사항에서는 외부 제공까지는 언급되지 않았으므로, 내부 사용을 위한 API만 설계합니다. 내부 API 명세는 다음과 같습니다.

### 3. 내부 API 명세 (주요 엔드포인트)

프론트엔드와 백엔드, 또는 다른 서비스 모듈 간 연동을 위해 **RESTful API**를 구성합니다. 아래는 핵심 기능에 대한 엔드포인트 설계입니다:

* **회원 인증 관련 API**:

  * `POST /api/auth/signup` : 회원가입 처리. 입력으로 `{ email, password, name }`를 받고, 서버에서 실명 인증 절차를 거친 후 사용자 생성. 성공 시 201 Created와 함께 JWT 토큰 또는 세션 쿠키 반환.
  * `POST /api/auth/login` : 로그인 처리. 입력으로 `{ email, password }` 받고 검증 후 성공 시 JWT/쿠키 반환, 실패 시 401 오류. (만약 NextAuth 등을 쓰는 경우 이 경로는 NextAuth의 credential provider로 대체됩니다.)
  * `POST /api/auth/logout` : 로그아웃 (필요시 서버측 세션 무효화. JWT인 경우 클라이언트에서 쿠키 삭제로 처리하므로 서버에는 해당 토큰을 블랙리스트에 올리는 등의 처리만 할 수 있음).
  * `GET /api/auth/profile` : (인증 필요) 로그인된 사용자의 프로필 조회. 자신의 이메일, 이름, 인증여부, 가입일 등을 반환. 이때도 민감정보는 제외.
  * `POST /api/auth/verify-realname` : (선택) 실명 인증 호출 엔드포인트. 프론트엔드에서 본인인증이 필요한 시점에 이 API를 호출하면, 서버가 연동된 외부 본인인증 절차를 수행하고 결과를 반환. (예: NICE/PASS API를 호출하고 결과를 정리). 성공 시 Users 테이블의 해당 사용자 `verified=true`로 업데이트.

* **사업 정보 관리 API**:

  * `GET /api/projects` : (인증 필요) 지원사업 목록 조회. 필터/검색 쿼리파라미터를 받을 수 있습니다 (예: `?keyword=청년&agency=중소벤처기업부`). 인증된 일반 사용자 이상 누구나 호출 가능. 결과는 페이징되어 제공되며, 각 아이템에는 프로젝트 기본 정보 포함.
  * `GET /api/projects/{id}` : (인증 필요) 특정 프로젝트의 상세 정보 조회. `{id}`는 내부 project\_id이거나 policy\_external\_id. 상세 정보에는 사업 개요, 신청 방법, 첨부 링크 등 모든 저장된 필드 제공.
  * `POST /api/projects` : (관리자 권한 필요) 새로운 사업 추가. 요청 바디에 프로젝트 필드들을 JSON으로 담아 전송. 성공 시 201 Created와 생성된 리소스 ID 반환. (관리자는 수동으로 사업을 입력할 때 이 API를 사용하며, UI 폼에서 해당 API를 호출하도록 구현)
  * `PUT /api/projects/{id}` : (관리자 권한 필요) 기존 사업 정보 수정. 변경할 필드를 담아 요청하면 해당 프로젝트 레코드를 업데이트. 성공 시 200 OK. (일부 필드만 수정 가능하도록 Patch를 고려할 수 있으나 단순화 위해 PUT 사용)
  * `DELETE /api/projects/{id}` : (관리자 권한 필요) 사업 삭제. 필요에 따라 소프트 삭제(삭제 플래그만 세팅)하거나 실제 삭제. 일반적으로는 데이터 보존을 위해 **삭제보다는 비활성화** 필드(`active`)를 두고 표시만 안 하게 할 수 있습니다.

* **외부 데이터 동기화 API**:

  * `POST /api/admin/sync-policies` : (관리자 권한 또는 내부 사용) 외부 공공데이터로부터 정책 목록을 동기화. 예를 들어 관리자가 대시보드에서 "데이터 동기화" 버튼을 누르면 이 API가 호출되어 백엔드에서 data.go.kr API를 수동으로 조회/저장 실행. 동기화한 항목 수 등을 응답으로 반환. (정기 스케줄러가 있다면 해당 기능을 내부적으로 호출)
  * `GET /api/admin/search-external?keyword=` : (관리자 권한) 실시간 외부 API 검색. 관리자 UI에서 새로운 사업을 추가하기 전에 혹시 이미 외부에 있는지 검색해볼 때 사용. 키워드로 외부 API 검색해서 결과를 그대로 반환하거나 가공하여 전달. 관리자는 결과를 보고 필요한 항목을 선택해 import할 수 있게 함. (선택 구현)

> **API 보안**: 상기 모든 API 엔드포인트는 **HTTPS**로만 접근 가능하며, HTTP 요청 시 리다이렉트 또는 차단합니다. 또한 `/api/admin/*` 경로 등의 민감 API는 **인증 + 관리자권한** 검증을 서버 측에서 진행하여, 권한 없는 접근을 차단합니다. JWT의 `role` 클레임 등을 검사하며, 권한 불충분 시 403 Forbidden을 반환합니다. 입력 파라미터에 대해서도 서버단에서 유효성 검증을 실시하여, SQL 인젝션이나 XSS 등이 없도록 합니다 (ORM이나 Prepared Statement 이용). 모든 요청/응답에는 JSON 형태를 사용하고, 필요 시 Rate Limiting을 적용하여 과도한 API 사용을 방지합니다.

## 보안 및 개인정보 고려사항

마지막으로, 전체 시스템 설계에서 고려한 **보안 요소**와 **개인정보 보호** 사항을 요약합니다.

* **최소한의 개인정보 수집**: 앞서 언급한대로 이메일, 이름 등 **서비스 운영에 필수적인 정보만 수집**합니다. 주민등록번호, 주소, 연락처 등은 지원사업 안내 서비스인 GovChat 운영에 반드시 필요하지 않으므로 수집 대상이 아닙니다. 이는 데이터 수집 최소화 원칙에 부합하며, 불필요한 개인정보를 저장하지 않음으로써 잠재적 유출 위험과 법적 컴플라이언스 부담을 줄입니다.
* **비밀번호 안전 저장**: 비밀번호는 복원 불가능한 해시로 저장하고, 해시화에 적절한 강도의 알고리즘(bcrypt, Argon2 등)을 사용합니다. 또한 데이터베이스가 유출되더라도 해시를 통한 역산이 어렵도록 충분한 솔트와 해시 비용을 적용합니다. 사용자에게는 주기적인 비밀번호 변경과 안전한 비밀번호 사용을 권고합니다.
* **통신 보안**: 클라이언트와 서버 간 모든 통신은 SSL/TLS로 암호화하여 중간에 탈취되더라도 내용을 확인할 수 없도록 합니다. 특히 로그인, 본인인증 등 민감 정보가 오가는 구간은 HTTPS 필수입니다. 또한 HttpOnly 쿠키를 사용해 자바스크립트로 토큰이 접근되지 않게 하고, 필요하면 `SameSite` 설정으로 크로스사이트 요청 위조(CSRF)를 방지합니다.
* **세션 보안**: JWT에는 필요한 최소 정보만 포함하고 민감한 개인정보를 담지 않습니다. 토큰에는 서명으로 무결성을 검증하며, 만료 시간을 설정해 영구적으로 유효하지 않게 합니다. 사용자 로그아웃이나 중요 정보 변경 시 기존 토큰을 폐기하도록 구현합니다. 만약 세션 ID 기반 서버 세션을 쓴다면 세션 쿠키에 `Secure` 플래그를 적용하고 세션 저장소(DB 등)는 접근 제어를 통해 안전하게 관리합니다.
* **권한 인증 철저**: 모든 API 엔드포인트 및 페이지 렌더링시 **인증/권한 체크**를 누락하지 않고 수행합니다. 프론트엔드 단에서도 메뉴 노출을 제어하지만, 최종적으로 백엔드에서 한 번 더 권한을 확인함으로써 신뢰성을 담보합니다. 예를 들어, 일반 사용자가 관리자 API를 호출하려 하면 서버에서 토큰의 role을 확인하여 즉시 차단합니다. 권한 부여는 RBAC 원칙을 따르며, 원칙적으로 사용자에게는 **업무상 필요한 권한만 부여**합니다.
* **관리자 계정 보안**: 관리자 계정(`archt723@gmail.com`)은 광범위한 권한을 가지므로, 특히 보안에 신경씁니다. 해당 계정의 초기 비밀번호는 개발/테스트 용도로만 사용하며, 운영 시 강력한 비밀번호로 교체 또는 별도 생성합니다. 가능하다면 관리자 계정 로그인에는 MFA를 적용하고, 관리자용 기능 사용 시 재인증(예: 비밀번호 재입력) 절차를 추가하여 **세션 탈취 대비**를 합니다. 또한 관리자 페이지 URL을 일반에 노출하지 않고, 관리자 전용 네트워크 대역에서만 접근 가능하게 하는 등 추가적 보안도 고려할 수 있습니다.
* **로그 및 감사**: 중요한 데이터 변경(예: 지원사업 추가/수정/삭제, 관리자 권한 부여 등)은 **로그로 남겨** 추후 추적 가능하게 합니다. 누구가 언제 어떤 데이터를 변경했는지 기록하여, 문제가 발생할 경우 원인을 파악하고 악의적 행위를 감지할 수 있습니다. 이 로그에는 개인정보를 과도하게 담지 않되 필요한 식별정보(변경 대상의 ID, 변경자 계정 등)는 포함합니다.
* **데이터 백업 및 복구**: DB의 중요한 데이터(지원사업 목록 등)는 정기 백업을 수행하고 장애나 실수로 인한 데이터 손실에 대비합니다. 개인정보는 최소 수집 원칙에 따라 많지 않겠지만, 사용자 계정 데이터베이스 역시 주기적으로 백업하고 암호화하여 안전한 별도 저장공간에 보관합니다.
* **개인정보 접근 통제**: 앞서 설명했듯이 관리자도 비밀번호 해시처럼 민감정보에는 접근할 수 없고, DB상에서도 해당 컬럼은 **암호화**하거나 **해시화**되어 저장됩니다. 운영 DB에 대한 접근은 최소 인원으로 제한하고, 실제 서비스 상에서도 본인이 제공한 정보 외에는 다른 사람의 정보를 볼 수 없습니다. 이러한 설계는 사용자 개인정보 보호 및 관련 법규(GDPR, 개인정보보호법 등)의 취지에도 부합합니다.
* **성능 및 한계**: 외부 API 의존 기능의 경우, 네트워크 지연이나 장애 시 서비스를 부분적으로 제한할 수 있는 대비책 (예: 마지막 동기화된 데이터 사용, 오류 메시지 안내)을 마련합니다. 또한 대량의 외부 데이터 처리 시 서버 부하에 대비해 **비동기 처리**나 **배치 작업**으로 off-load하고, 사용자 요청에는 캐시된 결과를 우선 제공하여 응답성을 높입니다.

以上のように, GovChat 프로젝트의 인증 및 데이터 입력 환경 설계는 **안전한 사용자 관리**, **철저한 권한 분리**, **신뢰할 수 있는 데이터 수집**을 핵심으로 합니다. 이 설계를 구현함으로써 사용자들은 편리하면서도 보호된 환경에서 서비스를 이용할 수 있고, 관리자는 체계적으로 데이터를 운영할 수 있을 것입니다. 각 설계 요소는 향후 시스템 확장과 변경 요구에도 유연하게 대응할 수 있도록 모듈화하고 표준 프로토콜(OAuth2/OIDC, RESTful API 등)을 준수하였으며, 보안 모범사례를 적용하여 서비스 신뢰성을 높였습니다.

**참고 자료:** 데이터 최소수집 및 KYC 원칙, 비밀번호 해시 처리 권장사항, 역할 기반 접근제어 개념, GovChat ADR-001(OIDC 인증 아키텍처 결정) 등.
